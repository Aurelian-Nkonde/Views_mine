// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db_quaries

import (
	"context"

	"github.com/google/uuid"
)

const createAccount = `-- name: CreateAccount :one
INSERT INTO accounts (
  username, email, password, account_id
) VALUES (
  $1, $2, $3, $4
)
RETURNING account_id, username, email, password, email_verified, active, created_at, updated_at, deleted_at
`

type CreateAccountParams struct {
	Username  string
	Email     string
	Password  string
	AccountID uuid.UUID
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, createAccount,
		arg.Username,
		arg.Email,
		arg.Password,
		arg.AccountID,
	)
	var i Account
	err := row.Scan(
		&i.AccountID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.EmailVerified,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createView = `-- name: CreateView :one
INSERT INTO views (
  title, paragraph, user_id, public
) VALUES (
  $1, $2, $3, $4
) RETURNING view_id, title, paragraph, user_id, public, created_at, updated_at, deleted_at
`

type CreateViewParams struct {
	Title     string
	Paragraph string
	UserID    uuid.UUID
	Public    bool
}

func (q *Queries) CreateView(ctx context.Context, arg CreateViewParams) (View, error) {
	row := q.db.QueryRow(ctx, createView,
		arg.Title,
		arg.Paragraph,
		arg.UserID,
		arg.Public,
	)
	var i View
	err := row.Scan(
		&i.ViewID,
		&i.Title,
		&i.Paragraph,
		&i.UserID,
		&i.Public,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteAccount = `-- name: DeleteAccount :exec
DELETE FROM accounts WHERE account_id = $1
`

func (q *Queries) DeleteAccount(ctx context.Context, accountID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAccount, accountID)
	return err
}

const deleteView = `-- name: DeleteView :exec
DELETE FROM views WHERE view_id = $1
`

func (q *Queries) DeleteView(ctx context.Context, viewID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteView, viewID)
	return err
}

const getAccount = `-- name: GetAccount :one
SELECT account_id, username, email, password, email_verified, active, created_at, updated_at, deleted_at FROM accounts WHERE account_id = $1 LIMIT 1
`

func (q *Queries) GetAccount(ctx context.Context, accountID uuid.UUID) (Account, error) {
	row := q.db.QueryRow(ctx, getAccount, accountID)
	var i Account
	err := row.Scan(
		&i.AccountID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.EmailVerified,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAccounts = `-- name: GetAccounts :many
SELECT account_id, username, email, password, email_verified, active, created_at, updated_at, deleted_at FROM accounts ORDER BY username
`

func (q *Queries) GetAccounts(ctx context.Context) ([]Account, error) {
	rows, err := q.db.Query(ctx, getAccounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.AccountID,
			&i.Username,
			&i.Email,
			&i.Password,
			&i.EmailVerified,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPublicViews = `-- name: GetAllPublicViews :many
SELECT view_id, title, paragraph, user_id, public, created_at, updated_at, deleted_at FROM views WHERE public = true ORDER BY created_at
`

func (q *Queries) GetAllPublicViews(ctx context.Context) ([]View, error) {
	rows, err := q.db.Query(ctx, getAllPublicViews)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []View
	for rows.Next() {
		var i View
		if err := rows.Scan(
			&i.ViewID,
			&i.Title,
			&i.Paragraph,
			&i.UserID,
			&i.Public,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllViews = `-- name: GetAllViews :many
SELECT view_id, title, paragraph, user_id, public, created_at, updated_at, deleted_at FROM views ORDER BY user_id
`

func (q *Queries) GetAllViews(ctx context.Context) ([]View, error) {
	rows, err := q.db.Query(ctx, getAllViews)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []View
	for rows.Next() {
		var i View
		if err := rows.Scan(
			&i.ViewID,
			&i.Title,
			&i.Paragraph,
			&i.UserID,
			&i.Public,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserViews = `-- name: GetUserViews :many
SELECT view_id, title, paragraph, user_id, public, created_at, updated_at, deleted_at FROM views WHERE user_id = $1
`

func (q *Queries) GetUserViews(ctx context.Context, userID uuid.UUID) ([]View, error) {
	rows, err := q.db.Query(ctx, getUserViews, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []View
	for rows.Next() {
		var i View
		if err := rows.Scan(
			&i.ViewID,
			&i.Title,
			&i.Paragraph,
			&i.UserID,
			&i.Public,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getView = `-- name: GetView :one
SELECT view_id, title, paragraph, user_id, public, created_at, updated_at, deleted_at FROM  views WHERE view_id = $1 LIMIT 1
`

func (q *Queries) GetView(ctx context.Context, viewID uuid.UUID) (View, error) {
	row := q.db.QueryRow(ctx, getView, viewID)
	var i View
	err := row.Scan(
		&i.ViewID,
		&i.Title,
		&i.Paragraph,
		&i.UserID,
		&i.Public,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const verifyEmail = `-- name: VerifyEmail :one
UPDATE accounts SET email_verified = $2
WHERE account_id = $1 RETURNING account_id, username, email, password, email_verified, active, created_at, updated_at, deleted_at
`

type VerifyEmailParams struct {
	AccountID     uuid.UUID
	EmailVerified bool
}

func (q *Queries) VerifyEmail(ctx context.Context, arg VerifyEmailParams) (Account, error) {
	row := q.db.QueryRow(ctx, verifyEmail, arg.AccountID, arg.EmailVerified)
	var i Account
	err := row.Scan(
		&i.AccountID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.EmailVerified,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
